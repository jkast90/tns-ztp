package dhcp

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"
	"text/template"
	"time"

	"github.com/ztp-server/backend/db"
	"github.com/ztp-server/backend/models"
)

// ConfigManager handles dnsmasq configuration generation
type ConfigManager struct {
	store          *db.Store
	configPath     string
	tftpDir        string
	templatesDir   string
	dnsmasqPidFile string
	dhcpInterface  string
	leasePath      string
}

// NewConfigManager creates a new config manager
func NewConfigManager(store *db.Store, configPath, tftpDir, templatesDir, pidFile, dhcpInterface, leasePath string) *ConfigManager {
	return &ConfigManager{
		store:          store,
		configPath:     configPath,
		tftpDir:        tftpDir,
		templatesDir:   templatesDir,
		dnsmasqPidFile: pidFile,
		dhcpInterface:  dhcpInterface,
		leasePath:      leasePath,
	}
}

// dnsmasqTemplate is the template for dnsmasq.conf
const dnsmasqTemplate = `# Auto-generated by ZTP Server - DO NOT EDIT
# Generated at: {{.GeneratedAt}}

# Run as root for Docker volume permissions
user=root

# DHCP Settings
interface={{.Interface}}
bind-interfaces
dhcp-range={{.Settings.DHCPRangeStart}},{{.Settings.DHCPRangeEnd}},{{.Settings.DHCPSubnet}},12h
dhcp-option=option:router,{{.Settings.DHCPGateway}}

# TFTP Settings
enable-tftp
tftp-root={{.TFTPDir}}

# Global DHCP Options (apply to all clients)
{{range .GlobalOptions}}
{{- if .Enabled}}
dhcp-option={{.OptionNumber}},{{.Value}}
{{- end}}
{{end}}

# Per-Device DHCP Options (vendor-specific based on device's vendor assignment)
{{range .Devices}}
{{- $mac := .MAC}}
{{- $vendorOpts := index $.VendorOptions .Vendor}}
{{- range $vendorOpts}}
{{- if .Enabled}}
dhcp-option=tag:{{$mac}},{{.OptionNumber}},{{.Value}}
{{- end}}
{{- end}}
{{end}}

# OpenGear ZTP Enrollment Options (vendor-specific options 1-3)
{{if .Settings.OpenGearEnrollURL}}
dhcp-option=vendor:OpenGear,1,{{.Settings.OpenGearEnrollURL}}
{{end}}
{{if .Settings.OpenGearEnrollBundle}}
dhcp-option=vendor:OpenGear,2,{{.Settings.OpenGearEnrollBundle}}
{{end}}
{{if .Settings.OpenGearEnrollPassword}}
dhcp-option=vendor:OpenGear,3,{{.Settings.OpenGearEnrollPassword}}
{{end}}

# Lease file for monitoring
dhcp-leasefile={{.LeasePath}}

# Logging
log-dhcp
log-queries

# Static DHCP reservations with vendor tags
{{range .Devices}}
{{- if .Vendor}}
dhcp-host={{.MAC}},set:{{.MAC}},{{.IP}},{{.Hostname}}
{{- else}}
dhcp-host={{.MAC}},{{.IP}},{{.Hostname}}
{{- end}}
{{end}}
`

// deviceConfigTemplate is a basic switch config template
const defaultDeviceTemplate = `! Configuration for {{.Hostname}}
! MAC: {{.MAC}}
! IP: {{.IP}}
!
hostname {{.Hostname}}
!
interface Vlan1
 ip address {{.IP}} {{.Subnet}}
 no shutdown
!
ip default-gateway {{.Gateway}}
!
line vty 0 4
 login local
 transport input ssh
!
end
`

// GenerateConfig regenerates all configuration files
func (m *ConfigManager) GenerateConfig() error {
	// Get all devices and settings
	devices, err := m.store.ListDevices()
	if err != nil {
		return fmt.Errorf("failed to list devices: %w", err)
	}

	settings, err := m.store.GetSettings()
	if err != nil {
		return fmt.Errorf("failed to get settings: %w", err)
	}

	// Clear lease file to force dnsmasq to use new static reservations
	// This is necessary because dnsmasq honors existing leases over static reservations
	if err := os.WriteFile(m.leasePath, []byte{}, 0644); err != nil {
		// Non-fatal, just log
		fmt.Printf("Warning: could not clear lease file: %v\n", err)
	}

	// Generate dnsmasq config
	if err := m.generateDnsmasqConfig(devices, settings); err != nil {
		return fmt.Errorf("failed to generate dnsmasq config: %w", err)
	}

	// Generate device configs
	if err := m.generateDeviceConfigs(devices, settings); err != nil {
		return fmt.Errorf("failed to generate device configs: %w", err)
	}

	// Reload dnsmasq
	if err := m.reloadDnsmasq(); err != nil {
		return fmt.Errorf("failed to reload dnsmasq: %w", err)
	}

	return nil
}

func (m *ConfigManager) generateDnsmasqConfig(devices []models.Device, settings *models.Settings) error {
	tmpl, err := template.New("dnsmasq").Parse(dnsmasqTemplate)
	if err != nil {
		return err
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(m.configPath), 0755); err != nil {
		return err
	}

	// Get DHCP options from database
	dhcpOptions, err := m.store.ListDhcpOptions()
	if err != nil {
		return fmt.Errorf("failed to list DHCP options: %w", err)
	}

	// Separate global options from vendor-specific options
	var globalOptions []models.DhcpOption
	vendorOptions := make(map[string][]models.DhcpOption)

	for _, opt := range dhcpOptions {
		// Substitute variables in the value
		value := m.substituteOptionVariables(opt.Value, settings)
		opt.Value = value

		if opt.VendorID == "" {
			globalOptions = append(globalOptions, opt)
		} else {
			vendorOptions[opt.VendorID] = append(vendorOptions[opt.VendorID], opt)
		}
	}

	file, err := os.Create(m.configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		GeneratedAt   string
		Interface     string
		LeasePath     string
		TFTPDir       string
		Settings      *models.Settings
		Devices       []models.Device
		GlobalOptions []models.DhcpOption
		VendorOptions map[string][]models.DhcpOption
	}{
		GeneratedAt:   "auto",
		Interface:     m.dhcpInterface,
		LeasePath:     m.leasePath,
		TFTPDir:       m.tftpDir,
		Settings:      settings,
		Devices:       devices,
		GlobalOptions: globalOptions,
		VendorOptions: vendorOptions,
	}

	return tmpl.Execute(file, data)
}

// substituteOptionVariables replaces variable placeholders in option values
func (m *ConfigManager) substituteOptionVariables(value string, settings *models.Settings) string {
	value = strings.ReplaceAll(value, "${tftp_server_ip}", settings.TFTPServerIP)
	value = strings.ReplaceAll(value, "${dhcp_gateway}", settings.DHCPGateway)
	return value
}

func (m *ConfigManager) generateDeviceConfigs(devices []models.Device, settings *models.Settings) error {
	// Ensure TFTP directory exists
	if err := os.MkdirAll(m.tftpDir, 0755); err != nil {
		return err
	}

	for _, device := range devices {
		if err := m.generateSingleDeviceConfig(&device, settings); err != nil {
			return fmt.Errorf("failed to generate config for %s: %w", device.MAC, err)
		}
	}

	return nil
}

func (m *ConfigManager) generateSingleDeviceConfig(device *models.Device, settings *models.Settings) error {
	// Determine which template to use
	templateContent := defaultDeviceTemplate

	// First try to load from database
	if device.ConfigTemplate != "" {
		if dbTemplate, err := m.store.GetTemplate(device.ConfigTemplate); err == nil && dbTemplate != nil {
			templateContent = dbTemplate.Content
		} else {
			// Fallback to file-based template for backwards compatibility
			customPath := filepath.Join(m.templatesDir, device.ConfigTemplate)
			if content, err := os.ReadFile(customPath); err == nil {
				templateContent = string(content)
			}
		}
	}

	tmpl, err := template.New("device").Parse(templateContent)
	if err != nil {
		return err
	}

	// Generate config filename based on MAC (replace colons with underscores)
	filename := strings.ReplaceAll(device.MAC, ":", "_") + ".cfg"
	configPath := filepath.Join(m.tftpDir, filename)

	file, err := os.Create(configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		*models.Device
		Subnet  string
		Gateway string
	}{
		Device:  device,
		Subnet:  settings.DHCPSubnet,
		Gateway: settings.DHCPGateway,
	}

	return tmpl.Execute(file, data)
}

func (m *ConfigManager) reloadDnsmasq() error {
	// Try to read PID file
	pidData, err := os.ReadFile(m.dnsmasqPidFile)
	if err != nil {
		// PID file doesn't exist, dnsmasq might not be running
		return nil
	}

	var pid int
	if _, err := fmt.Sscanf(string(pidData), "%d", &pid); err != nil {
		return fmt.Errorf("invalid pid file: %w", err)
	}

	// Find process and kill it (SIGHUP doesn't clear existing leases from memory)
	process, err := os.FindProcess(pid)
	if err != nil {
		return nil // Process not found, ignore
	}

	// Send SIGTERM to gracefully stop dnsmasq
	if err := process.Signal(syscall.SIGTERM); err != nil {
		// Process might already be dead
		fmt.Printf("Warning: could not stop dnsmasq (pid %d): %v\n", pid, err)
	}

	// Wait a moment for it to stop
	time.Sleep(500 * time.Millisecond)

	// Remove stale PID file
	os.Remove(m.dnsmasqPidFile)

	// Start dnsmasq fresh
	cmd := exec.Command("dnsmasq", "--keep-in-foreground", "--log-facility=-", "--conf-file="+m.configPath, "--pid-file="+m.dnsmasqPidFile)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start dnsmasq: %w", err)
	}

	fmt.Printf("Restarted dnsmasq with pid %d\n", cmd.Process.Pid)
	return nil
}

// GetConfigPath returns the path to a device's config file
func (m *ConfigManager) GetConfigPath(mac string) string {
	filename := strings.ReplaceAll(mac, ":", "_") + ".cfg"
	return filepath.Join(m.tftpDir, filename)
}
