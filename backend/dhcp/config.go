package dhcp

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"
	"text/template"

	"github.com/ztp-server/backend/db"
	"github.com/ztp-server/backend/models"
)

// ConfigManager handles dnsmasq configuration generation
type ConfigManager struct {
	store          *db.Store
	configPath     string
	tftpDir        string
	templatesDir   string
	dnsmasqPidFile string
}

// NewConfigManager creates a new config manager
func NewConfigManager(store *db.Store, configPath, tftpDir, templatesDir, pidFile string) *ConfigManager {
	return &ConfigManager{
		store:          store,
		configPath:     configPath,
		tftpDir:        tftpDir,
		templatesDir:   templatesDir,
		dnsmasqPidFile: pidFile,
	}
}

// dnsmasqTemplate is the template for dnsmasq.conf
const dnsmasqTemplate = `# Auto-generated by ZTP Server - DO NOT EDIT
# Generated at: {{.GeneratedAt}}

# Run as root for Docker volume permissions
user=root

# DHCP Settings
interface=eth0
bind-interfaces
dhcp-range={{.Settings.DHCPRangeStart}},{{.Settings.DHCPRangeEnd}},{{.Settings.DHCPSubnet}},12h
dhcp-option=option:router,{{.Settings.DHCPGateway}}

# TFTP Settings
enable-tftp
tftp-root=/tftp

# Global DHCP Options (apply to all clients)
{{range .GlobalOptions}}
{{- if .Enabled}}
dhcp-option={{.OptionNumber}},{{.Value}}
{{- end}}
{{end}}

# Per-Device DHCP Options (vendor-specific based on device's vendor assignment)
{{range .Devices}}
{{- $vendor := .Vendor}}
{{- $mac := .MAC}}
{{- range $.VendorOptions}}
{{- if eq .VendorID $vendor}}
{{- if .Enabled}}
dhcp-option=tag:{{$mac}},{{.OptionNumber}},{{.Value}}
{{- end}}
{{- end}}
{{- end}}
{{end}}

# OpenGear ZTP Enrollment Options (vendor-specific options 1-3)
{{if .Settings.OpenGearEnrollURL}}
dhcp-option=vendor:OpenGear,1,{{.Settings.OpenGearEnrollURL}}
{{end}}
{{if .Settings.OpenGearEnrollBundle}}
dhcp-option=vendor:OpenGear,2,{{.Settings.OpenGearEnrollBundle}}
{{end}}
{{if .Settings.OpenGearEnrollPassword}}
dhcp-option=vendor:OpenGear,3,{{.Settings.OpenGearEnrollPassword}}
{{end}}

# Lease file for monitoring
dhcp-leasefile=/var/lib/misc/dnsmasq.leases

# Logging
log-dhcp
log-queries

# Static DHCP reservations with vendor tags
{{range .Devices}}
{{- if .Vendor}}
dhcp-host={{.MAC}},set:{{.MAC}},{{.IP}},{{.Hostname}}
{{- else}}
dhcp-host={{.MAC}},{{.IP}},{{.Hostname}}
{{- end}}
{{end}}
`

// deviceConfigTemplate is a basic switch config template
const defaultDeviceTemplate = `! Configuration for {{.Hostname}}
! MAC: {{.MAC}}
! IP: {{.IP}}
!
hostname {{.Hostname}}
!
interface Vlan1
 ip address {{.IP}} {{.Subnet}}
 no shutdown
!
ip default-gateway {{.Gateway}}
!
line vty 0 4
 login local
 transport input ssh
!
end
`

// GenerateConfig regenerates all configuration files
func (m *ConfigManager) GenerateConfig() error {
	// Get all devices and settings
	devices, err := m.store.ListDevices()
	if err != nil {
		return fmt.Errorf("failed to list devices: %w", err)
	}

	settings, err := m.store.GetSettings()
	if err != nil {
		return fmt.Errorf("failed to get settings: %w", err)
	}

	// Generate dnsmasq config
	if err := m.generateDnsmasqConfig(devices, settings); err != nil {
		return fmt.Errorf("failed to generate dnsmasq config: %w", err)
	}

	// Generate device configs
	if err := m.generateDeviceConfigs(devices, settings); err != nil {
		return fmt.Errorf("failed to generate device configs: %w", err)
	}

	// Reload dnsmasq
	if err := m.reloadDnsmasq(); err != nil {
		return fmt.Errorf("failed to reload dnsmasq: %w", err)
	}

	return nil
}

func (m *ConfigManager) generateDnsmasqConfig(devices []models.Device, settings *models.Settings) error {
	tmpl, err := template.New("dnsmasq").Parse(dnsmasqTemplate)
	if err != nil {
		return err
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(m.configPath), 0755); err != nil {
		return err
	}

	// Get DHCP options from database
	dhcpOptions, err := m.store.ListDhcpOptions()
	if err != nil {
		return fmt.Errorf("failed to list DHCP options: %w", err)
	}

	// Separate global options from vendor-specific options
	var globalOptions []models.DhcpOption
	vendorOptions := make(map[string][]models.DhcpOption)

	for _, opt := range dhcpOptions {
		// Substitute variables in the value
		value := m.substituteOptionVariables(opt.Value, settings)
		opt.Value = value

		if opt.VendorID == "" {
			globalOptions = append(globalOptions, opt)
		} else {
			vendorOptions[opt.VendorID] = append(vendorOptions[opt.VendorID], opt)
		}
	}

	file, err := os.Create(m.configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		GeneratedAt   string
		Settings      *models.Settings
		Devices       []models.Device
		GlobalOptions []models.DhcpOption
		VendorOptions map[string][]models.DhcpOption
	}{
		GeneratedAt:   "auto",
		Settings:      settings,
		Devices:       devices,
		GlobalOptions: globalOptions,
		VendorOptions: vendorOptions,
	}

	return tmpl.Execute(file, data)
}

// substituteOptionVariables replaces variable placeholders in option values
func (m *ConfigManager) substituteOptionVariables(value string, settings *models.Settings) string {
	value = strings.ReplaceAll(value, "${tftp_server_ip}", settings.TFTPServerIP)
	value = strings.ReplaceAll(value, "${dhcp_gateway}", settings.DHCPGateway)
	return value
}

func (m *ConfigManager) generateDeviceConfigs(devices []models.Device, settings *models.Settings) error {
	// Ensure TFTP directory exists
	if err := os.MkdirAll(m.tftpDir, 0755); err != nil {
		return err
	}

	for _, device := range devices {
		if err := m.generateSingleDeviceConfig(&device, settings); err != nil {
			return fmt.Errorf("failed to generate config for %s: %w", device.MAC, err)
		}
	}

	return nil
}

func (m *ConfigManager) generateSingleDeviceConfig(device *models.Device, settings *models.Settings) error {
	// Determine which template to use
	templateContent := defaultDeviceTemplate

	// First try to load from database
	if device.ConfigTemplate != "" {
		if dbTemplate, err := m.store.GetTemplate(device.ConfigTemplate); err == nil && dbTemplate != nil {
			templateContent = dbTemplate.Content
		} else {
			// Fallback to file-based template for backwards compatibility
			customPath := filepath.Join(m.templatesDir, device.ConfigTemplate)
			if content, err := os.ReadFile(customPath); err == nil {
				templateContent = string(content)
			}
		}
	}

	tmpl, err := template.New("device").Parse(templateContent)
	if err != nil {
		return err
	}

	// Generate config filename based on MAC (replace colons with underscores)
	filename := strings.ReplaceAll(device.MAC, ":", "_") + ".cfg"
	configPath := filepath.Join(m.tftpDir, filename)

	file, err := os.Create(configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		*models.Device
		Subnet  string
		Gateway string
	}{
		Device:  device,
		Subnet:  settings.DHCPSubnet,
		Gateway: settings.DHCPGateway,
	}

	return tmpl.Execute(file, data)
}

func (m *ConfigManager) reloadDnsmasq() error {
	// Try to read PID file and send SIGHUP
	pidData, err := os.ReadFile(m.dnsmasqPidFile)
	if err != nil {
		// PID file doesn't exist, dnsmasq might not be running
		return nil
	}

	var pid int
	if _, err := fmt.Sscanf(string(pidData), "%d", &pid); err != nil {
		return fmt.Errorf("invalid pid file: %w", err)
	}

	// Find process and send SIGHUP
	process, err := os.FindProcess(pid)
	if err != nil {
		return nil // Process not found, ignore
	}

	return process.Signal(syscall.SIGHUP)
}

// GetConfigPath returns the path to a device's config file
func (m *ConfigManager) GetConfigPath(mac string) string {
	filename := strings.ReplaceAll(mac, ":", "_") + ".cfg"
	return filepath.Join(m.tftpDir, filename)
}
