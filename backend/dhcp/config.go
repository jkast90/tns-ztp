package dhcp

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"syscall"
	"text/template"

	"github.com/ztp-server/backend/db"
	"github.com/ztp-server/backend/models"
)

// ConfigManager handles dnsmasq configuration generation
type ConfigManager struct {
	store          *db.Store
	configPath     string
	tftpDir        string
	templatesDir   string
	dnsmasqPidFile string
}

// NewConfigManager creates a new config manager
func NewConfigManager(store *db.Store, configPath, tftpDir, templatesDir, pidFile string) *ConfigManager {
	return &ConfigManager{
		store:          store,
		configPath:     configPath,
		tftpDir:        tftpDir,
		templatesDir:   templatesDir,
		dnsmasqPidFile: pidFile,
	}
}

// dnsmasqTemplate is the template for dnsmasq.conf
const dnsmasqTemplate = `# Auto-generated by ZTP Server - DO NOT EDIT
# Generated at: {{.GeneratedAt}}

# Run as root for Docker volume permissions
user=root

# DHCP Settings
interface=eth0
bind-interfaces
dhcp-range={{.Settings.DHCPRangeStart}},{{.Settings.DHCPRangeEnd}},{{.Settings.DHCPSubnet}},12h
dhcp-option=option:router,{{.Settings.DHCPGateway}}

# TFTP Settings
enable-tftp
tftp-root=/tftp

# Boot options for ZTP
dhcp-option=66,{{.Settings.TFTPServerIP}}
dhcp-boot=config.cfg,ztp-server,{{.Settings.TFTPServerIP}}

# OpenGear ZTP Enrollment Options (vendor-specific options 1-3)
{{if .Settings.OpenGearEnrollURL}}
dhcp-option=vendor:OpenGear,1,{{.Settings.OpenGearEnrollURL}}
{{end}}
{{if .Settings.OpenGearEnrollBundle}}
dhcp-option=vendor:OpenGear,2,{{.Settings.OpenGearEnrollBundle}}
{{end}}
{{if .Settings.OpenGearEnrollPassword}}
dhcp-option=vendor:OpenGear,3,{{.Settings.OpenGearEnrollPassword}}
{{end}}

# Lease file for monitoring
dhcp-leasefile=/var/lib/misc/dnsmasq.leases

# Logging
log-dhcp
log-queries

# Static DHCP reservations
{{range .Devices}}
dhcp-host={{.MAC}},{{.IP}},{{.Hostname}}
{{end}}
`

// deviceConfigTemplate is a basic switch config template
const defaultDeviceTemplate = `! Configuration for {{.Hostname}}
! MAC: {{.MAC}}
! IP: {{.IP}}
!
hostname {{.Hostname}}
!
interface Vlan1
 ip address {{.IP}} {{.Subnet}}
 no shutdown
!
ip default-gateway {{.Gateway}}
!
line vty 0 4
 login local
 transport input ssh
!
end
`

// GenerateConfig regenerates all configuration files
func (m *ConfigManager) GenerateConfig() error {
	// Get all devices and settings
	devices, err := m.store.ListDevices()
	if err != nil {
		return fmt.Errorf("failed to list devices: %w", err)
	}

	settings, err := m.store.GetSettings()
	if err != nil {
		return fmt.Errorf("failed to get settings: %w", err)
	}

	// Generate dnsmasq config
	if err := m.generateDnsmasqConfig(devices, settings); err != nil {
		return fmt.Errorf("failed to generate dnsmasq config: %w", err)
	}

	// Generate device configs
	if err := m.generateDeviceConfigs(devices, settings); err != nil {
		return fmt.Errorf("failed to generate device configs: %w", err)
	}

	// Reload dnsmasq
	if err := m.reloadDnsmasq(); err != nil {
		return fmt.Errorf("failed to reload dnsmasq: %w", err)
	}

	return nil
}

func (m *ConfigManager) generateDnsmasqConfig(devices []models.Device, settings *models.Settings) error {
	tmpl, err := template.New("dnsmasq").Parse(dnsmasqTemplate)
	if err != nil {
		return err
	}

	// Ensure directory exists
	if err := os.MkdirAll(filepath.Dir(m.configPath), 0755); err != nil {
		return err
	}

	file, err := os.Create(m.configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		GeneratedAt string
		Settings    *models.Settings
		Devices     []models.Device
	}{
		GeneratedAt: "auto",
		Settings:    settings,
		Devices:     devices,
	}

	return tmpl.Execute(file, data)
}

func (m *ConfigManager) generateDeviceConfigs(devices []models.Device, settings *models.Settings) error {
	// Ensure TFTP directory exists
	if err := os.MkdirAll(m.tftpDir, 0755); err != nil {
		return err
	}

	for _, device := range devices {
		if err := m.generateSingleDeviceConfig(&device, settings); err != nil {
			return fmt.Errorf("failed to generate config for %s: %w", device.MAC, err)
		}
	}

	return nil
}

func (m *ConfigManager) generateSingleDeviceConfig(device *models.Device, settings *models.Settings) error {
	// Determine which template to use
	templateContent := defaultDeviceTemplate
	if device.ConfigTemplate != "" {
		customPath := filepath.Join(m.templatesDir, device.ConfigTemplate)
		if content, err := os.ReadFile(customPath); err == nil {
			templateContent = string(content)
		}
	}

	tmpl, err := template.New("device").Parse(templateContent)
	if err != nil {
		return err
	}

	// Generate config filename based on MAC (replace colons with underscores)
	filename := strings.ReplaceAll(device.MAC, ":", "_") + ".cfg"
	configPath := filepath.Join(m.tftpDir, filename)

	file, err := os.Create(configPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		*models.Device
		Subnet  string
		Gateway string
	}{
		Device:  device,
		Subnet:  settings.DHCPSubnet,
		Gateway: settings.DHCPGateway,
	}

	return tmpl.Execute(file, data)
}

func (m *ConfigManager) reloadDnsmasq() error {
	// Try to read PID file and send SIGHUP
	pidData, err := os.ReadFile(m.dnsmasqPidFile)
	if err != nil {
		// PID file doesn't exist, dnsmasq might not be running
		return nil
	}

	var pid int
	if _, err := fmt.Sscanf(string(pidData), "%d", &pid); err != nil {
		return fmt.Errorf("invalid pid file: %w", err)
	}

	// Find process and send SIGHUP
	process, err := os.FindProcess(pid)
	if err != nil {
		return nil // Process not found, ignore
	}

	return process.Signal(syscall.SIGHUP)
}

// GetConfigPath returns the path to a device's config file
func (m *ConfigManager) GetConfigPath(mac string) string {
	filename := strings.ReplaceAll(mac, ":", "_") + ".cfg"
	return filepath.Join(m.tftpDir, filename)
}
